package exec

import (
	"errors"
	"fmt"
	"log"
	"os"
	"regexp"
	"strings"

	opsChaos "github.com/gochaos-app/chaosTF/chaosOps"
	"github.com/gochaos-app/chaosTF/config"
	"github.com/hashicorp/hcl/v2"
	"github.com/hashicorp/hcl/v2/gohcl"
	"github.com/hashicorp/hcl/v2/hclwrite"
)

var tokens hclwrite.Tokens

const Name = "Autogenerated"
const Description = "This file is generated by chaosTF"

func getResources(file *hclwrite.File) ([]*hclwrite.Block, []string) {
	resourceBlocks := file.Body().Blocks()
	var resource []string
	var blocks []*hclwrite.Block
	for _, block := range resourceBlocks {
		if block.Type() == "resource" {
			resource = append(resource, block.Labels()[0])
			blocks = append(blocks, block)
		}
	}
	return blocks, resource
}

func openFile(path string) (*hclwrite.File, error) {
	content, err := os.ReadFile(path)
	if err != nil {
		log.Fatal(err)
		return nil, err
	}
	file, diags := hclwrite.ParseConfig(content, path, hcl.Pos{Line: 1, Column: 1})
	if diags.HasErrors() {
		return nil, errors.New("error parsing file")
	}
	return file, nil
}

func getLabels(block *hclwrite.Block, tag string) string {
	var unTag string
	blockTags := block.Body().GetAttribute("tags")

	parts := strings.Split(tag, ":")
	var key, value string
	if len(parts) == 2 {
		key = parts[0]
		value = parts[1]
	} else {
		log.Fatalln("Tagging should be in format key:value, eg. env:dev")
	}

	if blockTags != nil {
		tokenTags := blockTags.BuildTokens(tokens)
		pattern := fmt.Sprintf("%s = \"%s\"", key, value)
		regex := regexp.MustCompile(pattern)

		//match := regex.FindString(s)
		unTag = string(tokenTags.Bytes()[:])
		match := regex.FindString(unTag)

		// Check if a match was found.
		if match != "" {
			return match
		} else {
			return ""
		}
	}
	return ""
}

func LogicSingleFileRead(path, tags, action string) {
	hclFile, err := openFile(path)
	if err != nil {
		log.Fatal(err)
	}
	blocks, chaosResources := getResources(hclFile)

	var provider string
	var jobCfgArray []config.JobConfig
	var jobCfg config.JobConfig
	var GenConfig config.GenConfig
	//var chaosConfig config.ChaosConfig
	if len(blocks) != len(chaosResources) {
		fmt.Println("The number of resources in the file does not match the number of chaos resources")
		return
	}

	//Create Job config
	for i := range chaosResources {
		service := chaosResources[i]

		provider = strings.Split(service, "_")[0]
		chaosResource := cloudServices()(service)

		if getLabels(blocks[i], tags) != "" {
			chaos := opsChaos.ExecuteAction(action)
			provider = cloudType()(provider)

			jobCfg = config.JobConfig{
				Cloud:   provider,
				Service: chaosResource,
				Chaos: config.ChaosConfig{
					Tag:   tags,
					Chaos: chaos,
					Count: 1,
				},
			}
			jobCfgArray = append(jobCfgArray, jobCfg)
		} else {
			continue
		}

		GenConfig = config.GenConfig{
			App:         Name,
			Description: Description,
			Job:         jobCfgArray,
		}
	}

	f := hclwrite.NewEmptyFile()
	gohcl.EncodeIntoBody(&GenConfig, f.Body())

	err = os.WriteFile("output.hcl", f.Bytes(), 0644)
	if err != nil {
		log.Fatalf("Failed to write HCL file: %s", err)
	}

}
